<h1>Cascata, Especificidade e Herança</h1>

<img src="assets/render.png" alt="render" />

<section>
  <h2>Análise</h2>

  <h3>Cascata</h3>
  <p>Resolve conflitos entre diferentes regras.</p>
  <p>Ordem de prioridade:</p>
  <ul>
    <li>
      User-agent stylesheets (navegador padrão) — estilos default aplicados pelo
      browser.
    </li>
    <li>Author stylesheets (desenvolvedor) — arquivos CSS.</li>
    <li>
      <a
        target="_blank"
        href="https://www.thoughtco.com/user-style-sheet-3469931"
        >User stylesheets</a
      >
      — estilos que o usuário pode definir (via navegador ou extensões).
    </li>
    <li>
      <strong>Importância</strong> → <code>!important</code> do usuário
      <strong>></strong> <code>!important</code> do autor
      <strong>></strong> regras do autor <strong>></strong> regras do usuário
      <strong>></strong> browser.
    </li>
    <li>
      <strong>Especificidade</strong> → inline <strong>></strong> ID
      <strong>></strong> classe / pseudo-classe / atributo
      <strong>></strong> elemento / pseudo-elemento.
    </li>
    <li>
      <strong>Ordem</strong> → em caso de empate, vale a última declaração.
    </li>
  </ul>
  <a
    target="_blank"
    href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade#cascading_order"
    >Cascata / Precedencia</a
  >

  <h3>Herança</h3>
  <p>Valores propagados do pai para os filhos.</p>
  <ul>
    <li>
      Propriedades de texto (<code>color</code>, <code>font-family</code>,
      <code>line-height</code>) são herdadas.
    </li>
    <li>
      Propriedades de layout (como <code>margin</code> ou <code>padding</code>)
      não são herdadas.
    </li>
  </ul>
</section>

<section>
  <h2>Processamento</h2>
  <p>Valores finais de CSS</p>

  <table
    border="1"
    cellpadding="8"
    cellspacing="0"
    style="border-collapse: collapse; width: 100%; text-align: left"
  >
    <thead style="background: #f0f0f0">
      <tr>
        <th>Etapa</th>
        <th>Valor</th>
        <th>Descrição</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Valor declarado</strong></td>
        <td><code>font-size: 1.5em;</code></td>
        <td>O valor escrito pelo autor no CSS.</td>
      </tr>
      <tr>
        <td><strong>Valor após cascata</strong></td>
        <td><code>font-size: 1.5em;</code></td>
        <td>
          Resultado depois de aplicar importância, especificidade e ordem.
          Default: valor herdado (se a propriedade for herdável) ou ao valor
          inicial (initial value) (se não for herdável)
        </td>
      </tr>
      <tr>
        <td><strong>Valor especificado</strong></td>
        <td><code>font-size: 1.5em;</code></td>
        <td>
          O valor final atribuído ao elemento (ou herdado, se não houver
          declarado).
        </td>
      </tr>
      <tr>
        <td><strong>Valor computado</strong></td>
        <td><code>15px</code></td>
        <td>
          O navegador converte unidades relativas (<code>em</code>,
          <code>%</code>) em valores absolutos.
        </td>
      </tr>
      <tr>
        <td><strong>Valor usado</strong></td>
        <td><code>15px</code></td>
        <td>
          Resultado dos últimos cálculos antes da renderização, levando em conta
          o contexto (ex.: largura do pai).
        </td>
      </tr>
      <tr>
        <td><strong>Valor real</strong></td>
        <td><code>14.67px → 15px</code></td>
        <td>
          O valor aplicado, considerando restrições do browser (ex.:
          arredondamento de pixels).
        </td>
      </tr>
    </tbody>
  </table>
</section>

<section>
  <h2>Final: CSSOM + DOM = Render Tree</h2>
  <p>
    <strong>CSS Object Model</strong>: API que permite manipular CSS via
    JavaScript, do mesmo jeito que usamos o DOM. Funciona como uma representação
    em memória das regras CSS aplicadas, permitindo leitura e modificação
    dinâmica de estilos.
  </p>
</section>

<section>
  <h2>Renderização</h2>

  <h3>Visual Formatting Model</h3>
  <ul>
    <li>
      Algoritmo que calcula caixas e determina o layout dessas caixas para cada
      elemento na árvore de renderização, a fim de determinar o layout final da
      página.
    </li>
    <li>
      Considera fatores como:
      <ul>
        <li>Dimensões das caixas (calculadas pelo box model).</li>
        <li>Tipo de caixa: bloco, inline ou inline-block.</li>
        <li>
          Esquema de posicionamento: fluxo normal, flutuantes, absoluto ou
          relativo.
        </li>
        <li>Contexto de empilhamento: irmãos, pais, z-index.</li>
        <li>
          Informações externas: viewport, dimensões de imagens, outros fatores.
        </li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2>Controle da cascata e especificidade</h2>
  <img src="assets/specificity.png" alt="specificity" />

  <div class="example-1">
    <h3>Especificidade</h3>

    <p style="color: gray">inline (gray)</p>
    <p id="green">id (green)</p>
    <p class="blue">class (blue)</p>
    <p title="pink">attribute (pink)</p>
    <p>element (red)</p>
    <p>pseudo-class (purple)</p>
  </div>

  <div class="example-3">
    <h3>Modificadores</h3>

    <h4>Nenhum valor</h4>

    <ul>
      <li>universal (<code>*</code>)</li>
      <li>combinadores (<code>&gt; + ~</code>)</li>
      → tornam o seletor mais específico em relação à seleção, mas não
      acrescentam nenhum valor ao peso da especificidade
      <ul class="no-value">
        <li>Lorem</li>
        <li>Ipsum</li>
        <li>Dolor</li>
      </ul>
    </ul>

    <ul>
      <li><code>:where()</code> sempre tem especificidade zero.</li>
      <ul class="where">
        <li id="red">Red</li>
        <li class="green">Green</li>
      </ul>
    </ul>

    <ul>
      <li>
        <code>:is()</code> adota a <em>maior</em> especificidade entre os seus
        seletores.
      </li>
      <ul class="is">
        <li id="red">Red</li>
        <li class="green">Green</li>
      </ul>
    </ul>

    <ul>
      <li>
        <code>:not()</code> e <code>:has()</code> herdam a especificidade do
        seletor interno.
      </li>
      <ul class="not">
        <li id="red">Red</li>
        <li class="green">Green</li>
      </ul>
      <ul class="has">
        <li id="red">Red</li>
        <li class="green">Green</li>
      </ul>
    </ul>
  </div>

  <div class="example-4">
    <h4>Layer</h4>
    <p>
      O at-rule <code>layer</code> permite organizar CSS em camadas nomeadas. A
      ordem das camadas define a precedência entre blocos de estilos, antes
      mesmo da especificidade.
    </p>

    <ul>
      <li id="red">Red</li>
      <li class="green">Green</li>
    </ul>
  </div>

  <div class="example-5">
    <h4>Scope</h4>

    <p>
      A regra <code>scope</code> permite definir blocos de estilos aplicáveis
      apenas dentro de uma subárvore DOM específica. Isso ajuda a evitar
      seletores excessivamente específicos e diminuir acoplamento à estrutura
      HTML.
    </p>

    <ul class="scope">
      <li class="red">Red</li>
    </ul>
  </div>
</section>

<!-- 
  Próximos tópicos:
  - CSS Custom Properties (Variables)
  - CSS Performance
  -->
